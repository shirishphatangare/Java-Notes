A) Gradle - Intro

Gradle is a free and open source project and it is licensed under the Apache License.
Gradle requires JDK 6 or higher. Although Gradle uses Groovy, we don't have to install Groovy ourselves. Gradle bundles the Groovy libraries with the distribution.

1) Gradle is a project automation tool that has a wide range of applications. The basic aim of Gradle is to automate a wide variety of tasks performed by software developers, including compiling computer source code to binary code, packaging binary codes, running tests, deploying applications to production systems, and creating documentation.
2) DSL based on Groovy - Gradle uses a Domain Specific Language (DSL) based on Groovy to declare builds. The DSL provides a flexible language that can be extended by us. As the DSL is based on Groovy, we can write Groovy code to describe a build and use the power and expressiveness of the Groovy language. 
3) To get the most out of Gradle, it is best to also learn the basics of the Groovy language, but it is not necessary to start writing Gradle scripts.
4) The Gradle core itself is written in Java and Groovy.
5) Support for Ant Tasks and Maven repositories - Gradle supports Ant Tasks and projects. Maven and Ivy repositories are supported by Gradle to publish or fetch dependencies.
6)  Gradle Wrapper - The Gradle Wrapper allows us to execute Gradle builds even if Gradle is not installed on a computer. This is a great way to distribute source code and provide the build system with it so that the source code can be built.
7) Incremental builds - With Gradle, we have incremental builds.  If the sources have changed, the task is executed; but if the sources haven't changed, the execution of the task is skipped and the task is marked as being up to date.
8) Multi-project builds - Gradle has great support for multi-project builds. A project can simply be dependent on other projects or be a dependency of other projects. We can define a graph of dependencies among projects, and Gradle can resolve these dependencies for us. We have the flexibility to define our project layout as we want.

------------------------------------------------------------------------------------

B) Writing our first build script

1) A directory named init.d, where we can store Gradle scripts that need to be executed each time we run Gradle.
2) Gradle uses the concept of projects to define a related set of tasks. A Gradle build can have one or more projects. A project has one or more tasks. Tasks are a unit of work that need to be executed by the build. Examples of tasks are compiling source code, packaging class files into a JAR file, running tests, and deploying the application.


build.gradle

task helloWorld << { 
    println 'Hello world.' 
} 

gradle <task>  --> To run a build

Output 1 - 

$ gradle helloWorld
:helloWorld
Hello world.
BUILD SUCCESSFUL
Total time: 2.384 secs

Output 2 - 

$ gradle --quiet helloWorld
Hello world.

------------------------------------------------------------------------------------

C) Default Gradle Tasks 

1) gradle -q tasks --> To list all tasks runnable from root Gradle project

$ gradle -q tasks
------------------------------------------------------------
All tasks runnable from root project
------------------------------------------------------------

Build Setup tasks
-----------------
init - Initializes a new Gradle build. [incubating]
wrapper - Generates Gradle wrapper files. [incubating]

Help tasks
-----------------
components - Displays the components produced by root project  [incubating]
dependencies - Displays all dependencies declared in root project  
dependencyInsight - Displays the insight into a specific n dependency in root project.
help - Displays a help message.
model - Displays the configuration model of root project. [incubating]
projects - Displays the sub-projects of root project.
properties - Displays the properties of root project.
tasks - Displays the tasks runnable from root project

2) gradle tasks --all --> To see all tasks and more detail 
3) gradle help --task <task> --> To see more detail about a task 
4) incubating feature - means that the functionality can change in future versions of Gradle
5) Task name abbreviation feature of Gradle

Can we use gradle h to run helloWorld task ?
gradle h will conflict with default help task. So, to uniquely identify our helloWorld task, we use the hello or hW as shown below -

$ gradle -q hello
$ gradle -q hW  // abbreviate each word in a CamelCase task name

------------------------------------------------------------------------------------

D) Command-line options

The gradle command is used to execute a build. This command accepts several command-line options. 

1)We know the --quiet (or -q) option to reduce the output of a build. 
2)If we use the gradle --help (or -h or -?) option, we see the complete list of options.
3)Logging options --debug (or -d), --info (or -i), --stacktrace (or -s), and --full-stacktrace (or -S) options control how much output we see when we execute tasks. 
4)--info (or -i) output is not as verbose as with --debug, but it can provide a better understanding of the build steps.
5)If our build throws exceptions, we can see the stack trace information with the --stacktrace (or -s) and --full-stacktrace (or -S) options. The latter option will output the most information and is the most verbose.
5) Changing the dafault build file and directory - 

$ gradle --project-dir hello-world -q helloWorld // Change default build dir from current dir to hello-world
$ gradle --build-file hello.build -q helloWorld  // Change default build file from "build.gradle" to "hello.build"

6) Running tasks without execution
With the --dry-run (or -m) option, we can run all tasks without really executing them. When we use the dry-run option, we can see the tasks that are executed, so we get an insight on the tasks that are involved in a certain build scenario. We don't even have to worry whether the tasks are actually executed. Gradle builds up a Directed Acyclic Graph (DAG) with all tasks before any task is executed. The DAG is build so that the tasks will be executed in order of dependencies, and a task is only executed once (optimization).

7) Gradle daemon
We already discussed that Gradle executes in a JVM, and each time we invoke the gradle command, a new JVM is started, the Gradle classes and libraries are loaded, and the build is executed. We can reduce the build execution time if we don't have to load JVM and Gradle classes and libraries each time we execute a build. The --daemon command-line option starts a new Java process that will have all Gradle classes and libraries already loaded and then execute the build. Next time when we run Gradle build, only the build is executed as the JVM with the required Gradle classes and libraries is already running.

$ gradle --daemon helloWorld
Starting a new Gradle Daemon for this build (subsequent builds will be faster).
:helloWorld
Hello world.
BUILD SUCCESSFUL
Total time: 2.136 secs // Notice time 

$ gradle helloWorld
:helloWorld
Hello world.
BUILD SUCCESSFUL
Total time: 0.594 secs // Notice time 

Even though the daemon process is started, we can still run Gradle tasks without using the daemon. We use the --no-daemon command-line option to run a Gradle build, and then the daemon is not used

$ gradle --no-daemon helloWorld
:helloWorld
Hello world.
BUILD SUCCESSFUL
Total time: 1.325 secs // Notice time 

To stop the daemon process, we use the --stop command-line option

Instead of using the --daemon command-line option, we can use the org.gradle.daemon Java system property to enable the daemon. We can add this property to the GRADLE_OPTS environment variable so that it is always used when we run a Gradle build:

$ export GRADLE_OPTS="-Dorg.gradle.daemon=true"
$ gradle helloWorld
:helloWorld
Hello world.
BUILD SUCCESSFUL
Total time: 0.575 secs

We can add a gradle.properties file to the root of our project directory. In the file, we can define a org.gradle.daemon property and assign the  true value to enable the Gradle daemon for all builds that are executed from this directory.

8) Defining properties using an external file

Basically, we can set the properties for our project in an external file "gradle.properties". It is a plain text file with the name of the property and its value on separate lines. We can place the file in the project directory or Gradle user home directory. The default Gradle user home directory is $USER_HOME/.gradle. A property defined in the properties file, in the Gradle user home directory, overrides the property values defined in a properties file in the project directory.

9) Passing properties via the command line

Instead of defining the property directly in the build script or external file, we can use the -P command-line option to add an extra property to a build. We can also use the -P command-line option to set a value for an existing property. If we define a property using the -P command-line option, we can override a property with the same name defined in the external gradle.properties file.

task showProperties { 
    doLast { 
        println "Version: $version" 
        println "Custom property: $customProperty" 
    } 
} 


$ gradle -Pversion=1.1 -PcustomProperty=custom showProperties
:showProperties
Version: 1.1
Custom property: custom
BUILD SUCCESSFUL
Total time: 1.412 secs

10) Defining properties via system properties

We can also use Java system properties to define properties for our Gradle build. We use the -D command-line option just like in a normal Java application. The name of the system property must start with org.gradle.project, followed by the name of the property we want to set, and then by the value.


task showProperties { 
    doLast { 
        println "Version: $version" 
        println "Custom property: $customProperty" 
    } 
} 

$ gradle -Dorg.gradle.project.version=2.0 -Dorg.gradle.project.customProperty=custom showProperties
:showProperties
Version: 2.0
Custom property: custom
BUILD SUCCESSFUL
Total time: 1.218 secs

11) Adding properties via environment variables

Using the command-line options provides much flexibility; however, sometimes we cannot use the command-line options because of environment restrictions or because we don't want to retype the complete command-line options each time we invoke the Gradle build. Gradle can also use environment variables set in the operating system to pass properties to a Gradle build.

The environment variable name starts with ORG_GRADLE_PROJECT_ and is followed by the property name.

task showProperties { 
    doLast { 
        println "Version: $version" 
        println "Custom property: $customProperty" 
    } 
} 

$ ORG_GRADLE_PROJECT_version=3.1 \
ORG_GRADLE_PROJECT_customProperty="Set by environment variable" \
gradle showProp
:showProperties
Version: 3.1
Custom property: Set by environment variable
BUILD SUCCESSFUL
Total time: 1.373 secs

12) Offline usage -
If we don't have access to a network at some location, we might get errors from our Gradle build, when a task needs to download something from the Internet, for example. We can use the --offline command-line option to instruct Gradle to not access any network during the build. This way we can still execute the build if all necessary files are already available offline and we don't get an error.

13) $ gradle --gui --> Start a graphical shell for our Gradle builds

---------------------------------------------------------

Writing a build script

A) build.gradle - Using the explicit project variable name and Groovy property assignment syntax

// Assign value to description property.
project.description = 'Simple project'
 
// DSL to create a new task using
// Groovy << operator.
task simple << {
    println 'Running simple task for project ' +
      project.description
}

output of -- $ gradle simple

:simple
Running simple task for project Simple project
BUILD SUCCESSFUL
Total time: 0.57 secs

Gradle reads the script file (build.gradle) and creates a Project object. The build script configures the Project object, and finally, the set of tasks to be executed is determined and executed.

B) build.gradle - Using the Java syntax to set and get the value of the description property of the Project object --

// Use setDescription method
// to assign value instead of
// Groovy assignment.
project.setDescription('Simple project')
 
// Use create method to add new
// task instead of Groovy << operator.
project.getTasks().create('simple') {
    println 'Running simple task for project ' +
      project.description
}

---------------------------------------------------------

Defining tasks - Adding actions to tasks

1) We can use the doFirst and doLast methods to add actions to our task.

task first {
    doFirst {
        println 'Running first'
    }
}

Closures are an important part of Groovy and are used throughout Gradle build scripts. Closures are basically reusable pieces of code that can be assigned to a variable or passed to a method. A closure is defined by enclosing the piece of code with curly brackets ({... }). We can pass one or more parameters to the closures. We can define a name for the parameter and use this name in the code. This is what we did for the second and third tasks; wherein, we named the closure parameter task and taskObject, respectively.
 
task second {
    doLast { Task task ->
// Using explicit name 'task' as closure parameter.
        // We also defined the type of the parameter.
        // This can help the IDE to add code completion.
        println "Running ${task.name}"
    }
}
 
// Here we use the << operator
// as synonym for the doLast method.
task third << { taskObject ->
    println 'Running ' + taskObject.name
}

2) Defining actions with the Action interface

Gradle often has more than one way of defining something, as we will see throughout the book. Besides using closures to add actions to a task, we can also follows a more verbose way of passing an implementation class of the org.gradle.api.Action interface. The Action interface has one method: execute. This method is invoked when the task is executed. However, the closure syntax is denser and more readable.

task first {
    doFirst(
        new Action() {
          void execute(O task) {
            println "Running ${task.name}"
          }
       }
    )
}

------------------------------------------------------------------

Defining dependencies between tasks


1) In Gradle, we can add task dependencies with the dependsOn method for a task. We can specify a task name as the String value or task object as the argument. We can even specify more than one task name or object to specify multiple task dependencies. First, let's look at a simple task dependency:

task first << { task -> 
    println "Run ${task.name}" 
} 
 
task second << { task -> 
    println "Run ${task.name}" 
} 
 
// Define dependency of task second on task first with task name as the String value
second.dependsOn 'first' 

Note that we define the dependency of the second task on the first task, in the last line. When we run the script, we see that the first task is executed before the second task


$ gradle second
:first
Run first
:second
Run second
BUILD SUCCESSFUL
Total time: 0.583 secs

2) Another way of defining the dependency between tasks is to set the dependsOn property instead of using the dependsOn method. There is a subtle difference, Gradle just offers several ways to achieve the same result. In the following piece of code, we use the property to define the dependency of the second task. For the third task, we immediately define the property when we define the task.

task first << { task -> 
    println "Run ${task.name}" 
} 
 
task second << { task -> 
    println "Run ${task.name}" 
} 
 
// Use property syntax to define dependency. 
// dependsOn expects a collection object. 
second.dependsOn = ['first'] 
 
// Define dependsOn when we create the task. 
task third(dependsOn: 'second') << { task -> 
    println "Run ${task.name}" 
} 


When we run the third task on the command line, we see that all three tasks are executed, as follows:

$ gradle -q third
Run first
Run second
Run third

3) The dependency between tasks is lazy. We can define a dependency on a task that is defined later in the build script. 

4) We can assign the task closure to a variable. We can reuse the variable name in our task definitions. 


// We assign the task closure 
// to a variable. We can reuse 
// the variable name in our task definitions. 
def printTaskName = { task -> 
    println "Run ${task.name}" 
} 
 
// We use the variable with the closure. 
task third(dependsOn: 'second') << printTaskName 
 
task second(dependsOn: 'first') << printTaskName 
 
task first << printTaskName 

5) We can use the task object instead of the task name to define a task dependency.

def printTaskName = { task -> 
    println "Run ${task.name}" 
} 
 
task first << printTaskName 
 
// Here we use first (not the string value 'first') 
// as a value for dependsOn. 
task second(dependsOn: first) << printTaskName 

6) Defining dependencies via closures

We can also use a closure to define the task dependencies. The closure must return a single task name or object, or a collection of task names or task objects. Using this technique, we can really fine-tune the dependencies for our task. For example, in the following build script, we define a dependency for the second task on all tasks in the project with task names that have the letter 'f' in the task name.

def printTaskName = { task -> 
    println "Run ${task.name}" 
} 
 
task second << printTaskName 
 
// We use the dependsOn method 
// with a closure. 
second.dependsOn { 
    // We use the Groovy method findAll 
    // that returns all tasks that 
    // apply to the condition we define 
    // in the closure: the task name 
    // starts with the letter 'f'. 
    project.tasks.findAll { task -> 
        task.name.contains 'f' 
    } 
} 
 
task first << printTaskName 
 
task beforeSecond << printTaskName 


$ gradle second
:beforeSecond
Run beforeSecond
:first
Run first
:second
Run second
BUILD SUCCESSFUL
Total time: 0.602 secs

------------------------------------------------------------------

Setting default tasks

We can also define a default task or multiple default tasks that need to be executed, even if we don't explicitly set the task name. So, if we run the gradle command without arguments, the default task of our build script will be executed.

defaultTasks 'first', 'second'   // To set the default task or tasks, we use the defaultTasks method.
 
task first { 
    doLast { 
        println "I am first" 
    } 
} 
 
task second { 
    doFirst { 
        println "I am second" 
    } 
} 


$ gradle
:first
I am first
:second
I am second
BUILD SUCCESSFUL
Total time: 0.558 secs

------------------------------------------------------------------

Organizing tasks

1) Adding a description to tasks

To describe our task, we can set the description property of a task. The value of the description property is used by the task of Gradle.

defaultTasks 'second' 
 
// Use description property to set description. 
task first(description: 'Base task') << { 
    println "I am first" 
} 
 
task second( 
    dependsOn: first, 
    description: 'Secondary task') << { 
 
    println "I am second" 
} 


$ gradle tasks --all
...
Other tasks
-----------
second - Secondary task
    first - Base task


2) Grouping tasks together

With Gradle, we can also group tasks together in so-called task groups. A task group is a set of tasks that belong together, logically. We must assign a value to the group property of a task

defaultTasks 'second' 
 
// Define name of the 
// task group we want to use. 
def taskGroup = 'base' 
 
task first( 
    description: 'Base task', 
    group: taskGroup) << { 
 
    println "I am first" 
} 
 
task second( 
    dependsOn: first, 
    description: 'Secondary task', 
    group: taskGroup) << { 
 
    println "I am second" 
} 



$ gradle -q tasks --all
...
Base tasks
----------
first - Base task
second - Secondary task [first] // Note that the task dependency is appended to the description property of the second task.
...

3) Adding tasks in other ways
 
Until now, we have added tasks to our build project using the task keyword, followed by the name of the task.

task 'simple' << { task ->
    println "Running ${task.name}"
}


The following sample script defines a simpleTask variable with the simple string value. This expression is used to define the task. The result is that our project now contains a task with the name simple:

// Define name of task
// as a variable.
def simpleTask = 'simple'
 
// Variable is used for the task name.
task(simpleTask) << { task ->
    println "Running ${task.name}"
}


$ gradle -q tasks
...
Other tasks
-----------
simple
...

--------------------------------------------------------------

Using task rules

We have seen how to add tasks dynamically to our build project. However, we can also define so-called task rules. These rules are very flexible and allow us to add tasks to our project based on several parameters and project properties.

Suppose, we want to add an extra task that shows the description of every task in our project. If we have a task first in our project, we want to add a descFirst task to show the description property of the first task. With task rules, we define a pattern for new tasks. In our sample, this is desc<TaskName>; it is the desc prefix, followed by the name of the existing task. The following build script shows the implementation of the task rule:


task first(description: 'First task')
 
task second(description: 'Second task')
 
tasks.addRule(
    "Pattern: desc<TaskName>: " +
    "show description of a task.") { taskName ->
 
    if (taskName.startsWith('desc')) {
        // Remove 'desc' from the task name.
        def targetTaskName = taskName - 'desc'
 
      // Uncapitalize the task name.
      def targetTaskNameUncapitalize =
        targetTaskName[0].toLowerCase() +
          targetTaskName[1..-1]
 
      // Find the task in the project we search
      // the description for.
      def targetTask =
        project.tasks.findByName(
          targetTaskNameUncapitalize)
 
      if (targetTask) {
          task(taskName) << {
          println "Description of task ${targetTask.name} " +
            " -> ${targetTask.description}"
        }
      }
    }
}


If we run the tasks task, we see an extra Rules section in the output:

$ gradle tasks
...
Rules
-----
Pattern: desc<TaskName>: show description of a task.
...


So, we know we can invoke descFirst and descSecond for our project. Note that these two extra tasks are not shown in the Other tasks section, but the Rules section shows the pattern we can use.

If we execute the descFirst and descSecond tasks, we get the following output:


$ gradle descFirst descSecond
:descFirst
Description of task first  -> First task
:descSecond
Description of task second  -> Second task
BUILD SUCCESSFUL
Total time: 0.56 secs

-------------------------------------------------------------------

Accessing tasks as project properties



// Create a simple task.
task simple << { task ->
    println "Running ${task.name}"
}
 
// The simple task is available as
// project property.
simple.description = 'Print task name'
 
// We can invoke methods from the
// Task object.
simple.doLast {
    println "Done"
}
 
// We can also reference the task
// via the project property
// explicitly.
project.simple.doFirst {
    println "Start"
}


$ gradle -q simple
Start
Running simple
Done

-------------------------------------------------------------------

Adding additional properties to tasks

A task object already has several properties and methods. However, we can add any arbitrary new property to a task and use it. Gradle provides an ext namespace for the task object. We can set new properties and use them again once they are set. We can either set a property directly or use a closure to set a property with a value. In the following sample, we print the value of the message task property. The value of the property is assigned with the simple.ext.message = 'world' statement:

// Create simple task.
task simple << {
    println "Hello ${message}"
}
 
// We set the value for
// the non-existing message
// property with the task extension
// support.

simple.ext.message = 'world'

When we run the task, we get the following output:

:simple
Hello world
BUILD SUCCESSFUL
Total time: 0.584 secs

-------------------------------------------------------------------

Avoiding common pitfalls

A common mistake when creating a task and adding actions for this task is that we forget the left-shift operator (<<). Then we are left with a valid syntax in our build script, so we don't get an error when we execute the task. However, instead of adding actions, we have configured our task. The closure we use is then interpreted as a configuration closure. All methods and properties in the closure are applied to the task. We can add actions for our tasks in the configuration closure, but we must use the doFirst and doLast methods. We cannot use the left-shift operator (<<).

The following tasks do the same thing, but note the subtle differences when we define the tasks:


def printTaskName = { task ->
    println "Running ${task.name}"
}
 
task 'one' {
    // Invoke doFirst method to add action.
    doFirst printTaskName
}
 
// Assign action through left-shift operator (<<).
task 'two' << printTaskName
 
task 'three' {
    // This line will be displayed during configuration
    // and not when we execute the task,
    // because we use the configuration closure
    // and forgot the << operator.
    println "Running three"
}
 
defaultTasks 'one', 'two'

-------------------------------------------------------------------

Skipping tasks

1) Every task has an enabled property. By default, the value of the property is true, which means that the task is enabled and executed. We can change the value and set it to false in order to disable the task and skip its execution.

In the following sample, we check the existence of a directory, and if it exists, the enabled property is set to true; if not, it is set to false:


task listDirectory {
    def dir = new File('assemble')
 
    // Set value for enabled task property.
    enabled = dir.exists()
 
    // This is only executed if enabled is true.
    doLast {
        println "List directory contents: " +
                dir.listFiles().join(',')
    }
}

If we run the task and the directory doesn't exist, we get the following output:


$ gradle listDirectory
:listDirectory SKIPPED
BUILD SUCCESSFUL
Total time: 0.563 secs
If we run the task, and this time the directory exists, containing a single file with the name sample.txt, we get the following output:


$ gradle listDirectory
:listDirectory
List directory contents: assemble/sample.txt
BUILD SUCCESSFUL
Total time: 0.566 secs


2) We can use the --exclude-tasks (-x) command-line option if we run the build. We must define, as an argument, the task that we want to exclude from the tasks to be executed.

The following script has three tasks with some task dependencies:

// Define closure with task action.
def printTaskName = { task ->
    println "Run ${task.name}"
}
 
task first << printTaskName
 
task second(dependsOn: first) << printTaskName
 
task third(dependsOn: [second, first]) << printTaskName
If we run the gradle command and exclude the second task, we get the following output:

$ gradle third -x second
:first
Run first
:third
Run third
BUILD SUCCESSFUL
Total time: 0.573 secs

If our third task didn't depend on the first task, only the third task would be executed.

-------------------------------------------------------------------

Project properties

The default properties that we can access in a Gradle build are as below - 

version = '1.0' 
group = 'Sample' 
description = 'Sample build file to show project properties' 
 
task defaultProperties << { 
    println "Project: $project" 
    println "Name: $name" 
    println "Path: $path" 
    println "Project directory: $projectDir" 
    println "Build directory: $buildDir" 
    println "Version: $version" 
    println "Group: $project.group" 
    println "Description: $project.description" 
    println "AntBuilder: $ant" 
} 

$ gradle defaultProperties
:defaultProperties
Project: root project 'props'
Name: defaultProperties
Path: :defaultProperties
Project directory: /Users/mrhaki/gradle-book/Code_Files/props
Build directory: /Users/mrhaki/gradle-book/Code_Files/props/build
Version: 1.0
Group: Sample
Description: Sample build file to show project properties
AntBuilder: org.gradle.api.internal.project.DefaultAntBuilder@3c95cbbd
BUILD SUCCESSFUL
Total time: 1.458 secs


--------------------------------------------------------

Using the Gradle Wrapper

1) Normally, if we want to run a Gradle build, we must have Gradle installed on our computer. Also, if we distribute our project to others and they want to build the project, they must have Gradle installed on their computers. The Gradle Wrapper can be used to allow others to build our project even if they don't have Gradle installed on their computers.

2) The wrapper is a batch script on the Microsoft Windows operating systems or shell script on other operating systems that will download Gradle and run the build using the downloaded Gradle.

3) By using the wrapper, we can make sure that the correct Gradle version for the project is used. We can define the Gradle version, and if we run the build via the wrapper script file, the version of Gradle that we defined is used.

4) In the gradle/wrapper directory, relative to our project directory, we find the gradle-wrapper.jar and gradle-wrapper.properties files. The gradle-wrapper.jar file contains a couple of class files necessary to download and invoke Gradle. The gradle-wrapper.properties file contains settings, such as the URL, to download Gradle. The gradle-wrapper.properties file also contains the Gradle version number. If a new Gradle version is released, we only have to change the version in the gradle-wrapper.properties file and the Gradle Wrapper will download the new version so that we can use it to build our project.

5) To create the Gradle Wrapper batch and shell scripts, we can invoke the built-in wrapper task. This task is already available if we have installed Gradle on our computer. 

$ gradle wrapper
:wrapper
BUILD SUCCESSFUL
Total time: 0.61 secs

After the execution of the task, we have two script files — gradlew.bat and gradlew in the root of our project directory. These scripts contain all the logic needed to run Gradle. If Gradle is not downloaded yet, the Gradle distribution will be downloaded and installed locally.

6) All the generated files are now part of our project. If we use a version control system, then we must add these files to the version control. Other people that check out our project can use the gradlew scripts to execute tasks from the project. The specified Gradle version is downloaded and used to run the build file.

Typical project structure is as - 

projectRoot/
    src/
    build.gradle
    gradle.properties
    settings.gradle
    gradlew
    gradlew.bat
    gradle/
        wrapper/
            gradle-wrapper.jar
            gradle-wrapper.properties


7) If we want to use another Gradle version, we can invoke the wrapper task with the --gradle-version option. We must specify the Gradle version that the Wrapper files are generated for. By default, the Gradle version that is used to invoke the wrapper task is the Gradle version used by the wrapper files.

$ gradle wrapper --gradle-version=2.12
:wrapper
BUILD SUCCESSFUL
Total time: 0.61 secs

8) To specify a different download location for the Gradle installation file, we must use the --gradle-distribution-url option of the wrapper task. For example, we could have a customized Gradle installation on our local intranet, and with this option, we can generate the Wrapper files that will use the Gradle distribution on our intranet.


---------------------------------------------------------------------------

Using Gradle for Java Projects

The Gradle Java plugin

1) In Gradle, we can apply plugins to our project. A plugin basically adds extra functionalities such as tasks and properties to our project. Gradle has a Java plugin. This plugin adds tasks for compiling, testing, and packaging Java source code to our project.

2) Create a build file and use the Java plugin.

apply plugin: 'java' 

3) To see the tasks that have been added by the Java plugin, we run the tasks command on the command line and look at the output:

$ gradle tasks
:tasks
------------------------------------------------------------
All tasks runnable from root project
------------------------------------------------------------
Build tasks
-----------
assemble - Assembles the outputs of this project.
build - Assembles and tests this project.
buildDependents - Assembles and tests this project and all projects that depend on it.
buildNeeded - Assembles and tests this project and all projects it depends on.
classes - Assembles main classes.
clean - Deletes the build directory.
jar - Assembles a jar archive containing the main classes.
testClasses - Assembles test classes.
Build Setup tasks
-----------------
init - Initializes a new Gradle build. [incubating]
wrapper - Generates Gradle wrapper files. [incubating]
Documentation tasks
-------------------
javadoc - Generates Javadoc API documentation for the main source code.
Help tasks
----------
components - Displays the components produced by root project 'getting_started'. [incubating]
dependencies - Displays all dependencies declared in root project 'getting_started'.
dependencyInsight - Displays the insight into a specific dependency in root project 'getting_started'.
help - Displays a help message.
model - Displays the configuration model of root project 'getting_started'. [incubating]
projects - Displays the sub-projects of root project 'getting_started'.
properties - Displays the properties of root project 'getting_started'.
tasks - Displays the tasks runnable from root project 'getting_started'.
Verification tasks
------------------
check - Runs all checks.
test - Runs the unit tests.
Rules
-----
Pattern: clean<TaskName>: Cleans the output files of a task.
Pattern: build<ConfigurationName>: Assembles the artifacts of a configuration.
Pattern: upload<ConfigurationName>: Assembles and uploads the artifacts belonging to a configuration.
To see all tasks and more detail, run gradle tasks --all
To see more detail about a task, run gradle help --task <task>
BUILD SUCCESSFUL
Total time: 0.849 secs

4) The tasks added by the Java plugin are the visible part of the newly added functionality to our project. However, the plugin also adds the so-called convention object to our project. With the convention object, we can not only look at the properties used by the tasks in the plugin, but we can also change the value of the properties to reconfigure certain tasks.

5) By applying the Java plugin, we must now follow some conventions for our project directory structure. To build the source code, our Java source files must be in the src/main/java directory, relative to the project directory. If we have non-Java source files that need to be included in the JAR file, we must place them in the src/main/resources directory. Our test source files need to be in the src/test/java directory and any non-Java source files required for testing can be placed in src/test/resources. These conventions can be changed if we want or need it, but it is a good idea to stick with them so that we don't have to write any extra code in our build file, which could lead to errors.

6) Demo - Create a sample Java class and properties file and execute classes, jar, clean, assemble, build, test and javadoc  tasks.


a) classes task - To compile the Java source file and process the properties file, we run the classes task. Note that the classes task has been added by the Java plugin. This is the so-called life cycle task in Gradle. The classes task is actually dependent on two other tasks—compileJava and processResources


$ gradle classes
:compileJava
:processResources
:classes
BUILD SUCCESSFUL
Total time: 1.08 secs

The compiled class file and properties file are now in the build/classes/main and build/resources/main directories. The build directory is the default directory that Gradle uses to build output files.

If we execute the classes task again, we will notice that the tasks support the incremental build feature of Gradle. As we haven't changed the Java source file or the properties file, and the output is still present, all the tasks can be skipped as they are up-to-date:

$ gradle classes
:compileJava UP-TO-DATE
:processResources UP-TO-DATE
:classes UP-TO-DATE
BUILD SUCCESSFUL
Total time: 0.595 secs

b) jar task - To package our class file and properties file, we invoke the jar task. This task is also added by the Java plugin and depends on the classes task.

$ gradle jar
:compileJava UP-TO-DATE
:processResources UP-TO-DATE
:classes UP-TO-DATE
:jar
BUILD SUCCESSFUL
Total time: 0.585 secs

The default name of the resulting JAR file is the name of our project. So if our project is called sample, then the JAR file is called sample.jar. We can find the file in the build/libs directory.

c) clean task - To start again and clean all the generated output from the previous tasks, we can use the clean task. This task deletes the project build directory and all the generated files in this directory. So, if we execute the clean task from the command line, Gradle will delete the build directory.

$ gradle clean
:clean
BUILD SUCCESSFUL
Total time: 0.583 secs

d) assemble task - We can also execute the assemble task to create the JAR file. The assemble task, another life cycle task, is dependent on the jar task and can be extended by other plugins. We could also add dependencies on other tasks that create packages for a project other than the JAR file, such as a WAR file or ZIP archive file.

$ gradle assemble
:compileJava UP-TO-DATE
:processResources UP-TO-DATE
:classes UP-TO-DATE
:jar UP-TO-DATE
:assemble UP-TO-DATE
BUILD SUCCESSFUL
Total time: 0.607 secs

e) build task - build task compiles, tests, and assembles the code into a JAR file.




f) test task  - To make sure that the required JUnit classes are available to compile and run the test class, we must add JUnit as a dependency to our project. The Java plugin adds testCompile and testRuntime configurations that we can use. We add the JUnit dependency to the testCompile configuration. All JUnit classes are now available to compile the test classes.

To run our test, we only have to invoke the test task that is added by the Java plugin from the command line. 
In case of test failure, We can enable the info logging level with --info (or -i) arguments, as shown in the following command - 

$ gradle test --info
...
Gradle Test Executor 1 started executing tests.
Gradle Test Executor 1 finished executing tests.
gradle.sample.SampleTest > readWelcomeMessage FAILED
org.junit.ComparisonFailure: Get text from properties 
      file expected:<Welcome to Gradle[.]> but was:
     <Welcome to Gradle[!]>
      at org.junit.Assert.assertEquals(Assert.java:115)
      at  gradle.sample.SampleTest.readWelcomeMessage
     (SampleTest.java:16)
...

When we execute the test task from the command line, we can see the order of the tasks that are executed:

$ gradle test
:clean
:compileJava
:processResources
:classes
:compileTestJava
:processTestResources UP-TO-DATE
:testClasses
:test
:testReport
BUILD SUCCESSFUL
Total time: 1.285 secs


If we open the build/reports/tests/index.html file in a web browser, we get a clear overview of the tests that have run and failed.


f) Javadoc  task - To generate a Javadoc documentation, we must use the javadoc task. The task generates a documentation for the Java source files in the main source set. When we run the javadoc task, the documentation is generated and put into the build/docs/javadoc directory.

$ gradle javadoc
:compileJava
:processResources
:classes
:javadoc
BUILD SUCCESSFUL
Total time: 1.503 secs

----------------------------------------------------------------------------

Dependency Management

1) When we develop our code, we usually use third-party or open source libraries. These libraries need to be available in the classpath of the compiler, otherwise we will get errors and our build will fail. Gradle provides support for dependency management, so we can define our dependencies in our build file. Gradle will then take care of the necessary configuration for our various tasks.

2) In a Gradle build file, we group dependencies together in a configuration. A configuration has a name and configurations can extend each other. With a configuration, we can make logical groups of dependencies. For example, we can create a javaCompile configuration to include dependencies needed to compile the Java code. We can add as many configurations to our build as we want. We don't define our dependencies directly in the configuration. A configuration, as with a label, can be used when we define a dependency.

PPT - Configurations

3) After applying Java Plugin, if we execute the dependencies task

apply plugin: 'java'

$ gradle -q dependencies
------------------------------------------------------------
Root project
------------------------------------------------------------
archives - Configuration for archive artifacts.
No dependencies
compile - Compile classpath for source set 'main'.
No dependencies
default - Configuration for default artifacts.
No dependencies
runtime - Runtime classpath for source set 'main'.
No dependencies
testCompile - Compile classpath for source set 'test'.
No dependencies
testRuntime - Runtime classpath for source set 'test'.
No dependencies

--------------------------------------------------------------

Repositories

Dependencies are usually stored in some kind of repository. A repository has a layout that defines a pattern for the path of a versioned library module. Gradle knows, for example, the layout of a Maven repository. Ivy repositories can have customized layouts, and with Gradle, we can configure a customized layout. The repository can be accessible via the filesystem, HTTP, SSH, or other protocols.

PPT - Repositories

We define a repository with the repositories() method. 

repositories { 
    // Define Bintray's JCenter 
    // repository, to find 
    // dependencies. 
    jcenter() 
 
    // Define Maven Central 
    // as repository for 
    // dependencies. 
    mavenCentral() 
	
	// Maven will use a hidden folder in our home directory to store 
	// the downloaded dependency libraries. We can add this local 
	// Maven repository with the mavenLocal() method to the list of repositories.
	mavenLocal() 
	
	// Alternative way to define 
    // flat directory as repository. 
    flatDir { 
        dirs '../project-files', '/volumes/shared-libs' 
        name = 'All dependency directories' 
    } 
	
	
	// maven repository available through local intranet
	maven(name: 'Secured repository') { 
 
        // Set credentials to access 
        // the repository. It is better 
        // to store the values for username 
        // and password outside the build file like gradle.properties 
        credentials { 
            username = 'username' 
            password = 'password' 
      } 
 
      url = 'http://intranet/repo' 
    } 
} 

-----------------------------------------------

Defining dependencies

1) We define dependencies in our build project with the dependencies{} script block. We define a closure to pass to the dependencies{} script block with the configuration of the dependency.

Dependency types - PPT 


2) In the following example build file, we will use the Java plugin so that we get a compile and runtime dependency configuration. We will also assign several external module dependencies to each configuration using the different syntax rules:

apply plugin: 'java' 
 
repositories { 
    jcenter() 
} 
 
dependencies { 
    // Use attributes for the group, name and 
    // version for the external module dependency. 
    compile(group: 'org.springframework', 
      name: 'spring-core', 
      version: '4.2.3.RELEASE') 
 
    // Use String notation with group, name and 
    // version in a single String. 
    runtime('org.springframework:spring-aop:4.2.3.RELEASE' 
} 

Remember that a Gradle build file is a Groovy script file, so we can define variables to set values and use them in the dependencies{} script block configuration closure. If we rewrite the previous build file, we get the following output:

apply plugin: 'java' 
 
repositories { 
    jcenter() 
} 
 
ext { 
    springVersion = '4.2.3.RELEASE' 
    springGroup = 'org.springframework' 
} 
 
dependencies { 
    // Use attributes to define dependency and 
    // refer to project properties. 
    compile(group: springGroup, 
      name: 'spring-core', 
      version: springVersion) 
 
    // Use String notation with expression support 
    // for variables. 
    runtime("$springGroup:spring-aop:$springVersion") 
} 

3) To see the dependencies and the transitive dependencies, we invoke the built-in dependencies task. We get the following output:

$ gradle -q dependencies
------------------------------------------------------------
Root project
------------------------------------------------------------
archives - Configuration for archive artifacts.
No dependencies
compile - Compile classpath for source set 'main'.
\--- org.springframework:spring-core:4.2.3.RELEASE
    \--- commons-logging:commons-logging:1.2
default - Configuration for default artifacts.
+--- org.springframework:spring-core:4.2.3.RELEASE
|    \--- commons-logging:commons-logging:1.2
\--- org.springframework:spring-aop:4.2.3.RELEASE
    +--- aopalliance:aopalliance:1.0
    +--- org.springframework:spring-beans:4.2.3.RELEASE
    |    \--- org.springframework:spring-core:4.2.3.RELEASE (*)
    \--- org.springframework:spring-core:4.2.3.RELEASE (*)
runtime - Runtime classpath for source set 'main'.
+--- org.springframework:spring-core:4.2.3.RELEASE
|    \--- commons-logging:commons-logging:1.2
\--- org.springframework:spring-aop:4.2.3.RELEASE
    +--- aopalliance:aopalliance:1.0
    +--- org.springframework:spring-beans:4.2.3.RELEASE
    |    \--- org.springframework:spring-core:4.2.3.RELEASE (*)
    \--- org.springframework:spring-core:4.2.3.RELEASE (*)
testCompile - Compile classpath for source set 'test'.
\--- org.springframework:spring-core:4.2.3.RELEASE
    \--- commons-logging:commons-logging:1.2
testRuntime - Runtime classpath for source set 'test'.
+--- org.springframework:spring-core:4.2.3.RELEASE
|    \--- commons-logging:commons-logging:1.2
\--- org.springframework:spring-aop:4.2.3.RELEASE
    +--- aopalliance:aopalliance:1.0
    +--- org.springframework:spring-beans:4.2.3.RELEASE
    |    \--- org.springframework:spring-core:4.2.3.RELEASE (*)
    \--- org.springframework:spring-core:4.2.3.RELEASE (*)
(*) - dependencies omitted (listed previously)

4) To download only the artifact of an external dependency and not the transitive dependencies, we can set the transitive property for the dependency to false as follows:

apply plugin: 'java' 
 
repositories { 
    jcenter() 
} 
 
dependencies { 
    // Configure transitive property with closure. 
    compile('org.slf4j:slf4j-simple:1.7.13') { 
        transitive = false 
    } 
 
    // Or we can use the transitive property 
    // as argument. 
    compile(group: 'org.slf4j', 
      name: 'slf4j-simple', 
      version: '1.7.13', 
      transitive: false) 
} 

5) We can also exclude some transitive dependencies with the exclude() method. Gradle will look at the descriptor file of the module and exclude any dependencies that we have added with the exclude() method.

For example, in the following build file, we exclude the org.slf4j:sl4j-api transitive dependency:

apply plugin: 'java' 
 
repositories { 
    jcenter() 
} 
 
dependencies { 
    // Configure transitive property with closure. 
    compile('org.slf4j:slf4j-simple:1.7.13') { 
        exclude 'org.slf4j:slf4j-api' 
    } 
} 

6) We can use the files() and fileTree() methods to add dependencies to a configuration. The dependency must be resolved to an actual artifact.

The following example uses file dependencies for the compile configuration:

apply plugin: 'java' 
 
dependencies { 
    compile files('spring-core.jar', 'spring-aop.jar') 
    compile fileTree(dir: 'deps', include: '*.jar') 
} 

7) To set a minimum version number, we can use a special dynamic version syntax. For example, to set the dependency version to a minimum of 2.1 for a dependency, we use a version value 2.1.+. Gradle will resolve the dependency to the latest version after version 2.1 or to version 2.1 itself.

8) If we have a project with a lot of dependencies and these dependencies have transitive dependencies, version conflicts can easily arise. If one module has a dependency on sample:logging:1.0 and another on sample:logging:2.0, Gradle will use the newest version number by default.

To change the default behavior, we set the resolutionStrategy property of a dependency configuration. We can instruct Gradle to fail the build if a conflict arises. This is very useful for debugging version conflicts.

In the following example build file, we instruct Gradle to fail the build if a version conflicts arises for all configurations:


apply plugin: 'java' 
 
configurations.all { 
    resolutionStrategy { 
        failOnVersionConflict() 
    } 
} 

To force a certain version number to be used for all dependencies (even transitive dependencies), we can use the force() method of resolutionStrategy. With this method, we can make sure that the preferred version is always used for a given module:

apply plugin: 'java' 
 
configurations.all { 
    resolutionStrategy { 
        force('org.springframework:spring-core:4.2.3.RELEASE') 
    } 
} 

------------------------------------------------------------------------

Testing, Building, and Publishing Artifacts

1) Gradle supports both JUnit and TestNG testing frameworks. Gradle has a built-in support for running tests for our Java projects. When we add the Java plugin to our project, we will get new tasks to compile and run tests. We will also get the testCompile and testRuntime dependency configurations. We use these dependencies to set the class path for running the tests in our code base.

2) Configuring the test process

To debug the tests, we can set the debug property of the test task. Gradle will start the test process in the debug mode and listen on port 5005 for a debug process to attach to. This way we can run our tests and use an IDE debugger to step through the code.

By default, Gradle will fail the build if any test fails. If we want to change this setting, we must set the ignoreFailures property to true. 


apply plugin: 'java' 
 
repositories { 
    jcenter() 
} 
 
dependencies { 
    testCompile('junit:junit:4.12') 
} 
 
test { 
    // Add System property to running tests. 
    systemProperty 'sysProp', 'value' 
 
    // Use the following JVM arguments for each test process. 
    jvmArgs '-Xms256m', '-Xmx512m' 
 
    // Enable debugging mode. 
    debug = true 
 
    // Ignore any test failues and don't fail the build. 
    ignoreFailures = true 
 
    // Enable assertions for test with the assert keyword. 
    enableAssertions = true 
} 

3) Gradle can execute tests simultaneously. This means that Gradle will start multiple test processes concurrently. A test process only executes a single test at a time. By enabling parallel test execution, the total execution time of the test task can drastically decrease if we have a lot of tests.

4) We can disable this automatic inspection and determination with the scanForTestClasses property of the test task. If we set the property to false, Gradle will use the implicit /Tests.class and /*Test.class include rules and the */Abstract*.class exclude rule.

We can also set our own include and exclude rules to find tests. In the following build file, we will disable the automatic class inspection for test classes and set the include and exclude rules for test classes, explicitly:

apply plugin: 'java' 
 
repositories { 
    jcenter() 
} 
 
dependencies { 
    testCompile('junit:junit:4.12') 
} 
 
test { 
    // Disable automatic scanning 
    // for test classes. 
    scanForTestClasses = false 
 
    // Include test classes. 
    include('**/*Test.class', '**/*Spec.class') 
 
    // Exclude test classes. 
    exclude('**/Abstract*.class', '**/Run*.class') 
} 

--------------------------------------------------------------------------

Running Java applications

To run our SampleApp class, we can use the javaexec() method, which is part of Gradle's Project class. We can also use the JavaExec task in our build file. 

1) We will create a new build file and use the javaexec() method to run our SampleApp class with some extra options:

apply plugin: 'java' 
 
task runJava(dependsOn: classes, 
    description: 'Run gradle.sample.SampleApp') << { 
 
    javaexec { 
        // Java main class to execute. 
        main = 'gradle.sample.SampleApp' 
 
        // We need to set the classpath. 
        classpath sourceSets.main.runtimeClasspath 
 
        // Extra options can be set. 
        maxHeapSize = '128m' 
        systemProperty 'sysProp', 'notUsed' 
        jvmArgs '-client' 
    } 
 
} 
repositories { 
    jcenter() 
} 


$ gradle runJava
:compileJava
:processResources
:classes
:runJava
Welcome to Gradle.
BUILD SUCCESSFUL
Total time: 0.761 secs


2) In the following sample build file, we will create the runJava task of the JavaExec type. We will configure the task to set the class path and main class. Also, we will see how to add other properties and invoke other methods to further configure the execution of the Java class, as follows:

apply plugin: 'java' 
 
task runJava(type: JavaExec) { 
    dependsOn classes 
    description = 'Run gradle.sample.SampleApp' 
 
    // Java main class to execute. 
    main = 'gradle.sample.SampleApp' 
 
    // We need to set the classpath. 
    classpath sourceSets.main.runtimeClasspath 
 
    // Extra options can be set. 
    systemProperty 'sysProp', 'notUsed' 
    jvmArgs '-client' 
 
    // We can pass arguments to the main() method 
    // of gradle.sample.SampleApp. 
    args 'mainMethodArgument', 'notUsed' 
} 


$ gradle runJava
:compileJava UP-TO-DATE
:processResources UP-TO-DATE
:classes UP-TO-DATE
:runJava
Welcome to Gradle.
BUILD SUCCESSFUL
Total time: 0.686 secs

With the application plugin, we can create a distributable ZIP file with all the code and scripts necessary to run the Java application that we have built.
 
--------------------------------------------------------------------------

Publishing artifacts

A software project can contain artifacts that we want to publish. An artifact can be a ZIP or JAR archive file or any other file. In Gradle, we can define more than one artifact for a project. We can publish these artifacts in a central repository so that other developers can use our artifacts in their projects. These central repositories can be available on the company intranet, network drive, or via the Internet.


apply plugin: 'java' 
 
archivesBaseName = 'gradle-sample' 
version = '1.0' 
 
repositories { 
    flatDir { 
        name 'uploadRepository' 
        dirs 'upload' 
    } 
} 
 
uploadArchives { 
    repositories { 
        // Use repository defined in project 
        // for uploading the JAR file. 
        add project.repositories.uploadRepository 
 
        // Extra upload repository defined in 
        // the upload task. 
        flatDir { 
            dirs 'libs' 
        } 
    } 
} 


As we use the Java plugin, we have the default archives configuration available. When we execute the buildArchives task, our Java code is compiled and a JAR file is created in the build/libs directory, called gradle-sample-1.0.jar.

To publish our JAR file, we can execute the uploadArchives task, but we must first configure where to publish the artifact. The repositories that we have defined for the dependencies are not used to upload the artifacts. We have to define the upload repository in the uploadArchives task. We can reference a repository that is already defined in our project or define the repositories in the task.

If we invoke the uploadArchives task, the JAR file is created and copied to the libs and upload directories in our project root directory. An ivy.xml configuration file is also created and copied to the directories


$ gradle uploadArchives
:compileJava
:processResources
:classes
:jar
:uploadArchives
BUILD SUCCESSFUL
Total time: 0.753 secs

$ ls libs/
gradle-sample-1.0.jar
gradle-sample-1.0.jar.sha1
ivy-1.0.xml
ivy-1.0.xml.sha1

$ ls upload/
gradle-sample-1.0.jar
gradle-sample-1.0.jar.sha1
ivy-1.0.xml
ivy-1.0.xml.sha1

To digitally sign our artifacts, we can use the signing plugin together with locally-installed PGP tools.

----------------------------------------------------------------------

Creating a WAR file

To create a WAR file, we can add a new task of the War type to our Java project. The properties and methods of the War task are the same as for the other archive tasks, such as Jar. In fact, the War task extends the Jar task.

In the following sample build file, we will define a new War task. We set the root of the WAR file contents to the src/main/webapp directory. We use the webInf() and classpath() methods to customize the contents of the WEB-INF, WEB-INF/classes, and WEB-INF/lib folders. We also set a custom web.xml file with the webXml property of the task, as follows:


apply plugin: 'java' 
 
version = '1.0' 
 
// Custom archive task with 
// specific properties for a WAR archive. 
task war(type: War) { 
    dependsOn classes 
 
    from 'src/main/webapp' 
 
    // Files copied to WEB-INF. 
    webInf { 
        from 'src/main/webInf' 
    } 
 
    // Copied to WEB-INF/classes. 
    classpath sourceSets.main.runtimeClasspath 
 
    // Copied to WEB-INF/lib. 
    classpath fileTree('libs') 
 
    // Custom web.xml. 
    webXml = file('  ') 
    baseName = 'gradle-webapp' 
} 
 
assemble.dependsOn war 

To create the WAR file, we can execute the War or assemble task. The War task is added to the assemble task as a task dependency. This is why if we invoke the assemble task, Gradle will execute the War task. Once we have executed the task, the gradle-webapp-1.0.war WAR file is created in the build/libs directory:


$ gradle war
:compileJava
:processResources
:classes
:war
BUILD SUCCESSFUL
Total time: 0.727 secs
$ ls build/libs
gradle-webapp-1.0.war



Creating an EAR file

To create an EAR file, we can create a new task of the Ear type. This task has the same properties and methods as the Jar task. The Ear task extends the Jar task.

With the lib() method, we can define the files that need to be copied to the lib directory in the EAR file.

The following build file has a simple Ear task:


apply plugin: 'java' 
 
version = '1.0' 
 
// Create custom archive task 
// with specific properties to 
// create an EAR archive file. 
task ear(type: Ear) { 
    from 'src/main/application' 
 
    lib { 
        from fileTree('earLibs') 
    } 
 
    baseName = 'gradle-enterprise-app' 
} 
 
assemble.dependsOn ear 

We can execute the Ear task and look in the build/libs directory to see the resulting gradle-enterprise-app-1.0.ear file:

$ gradle ear
:ear
BUILD SUCCESSFUL
Total time: 0.694 secs
$ ls build/libs
gradle-enterprise-app-1.0.ear

































































































































