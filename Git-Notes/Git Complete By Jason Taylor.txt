Git Complete By Jason Taylor
---------------------------------
Introduction

1) There are 2 main types of source control systems - Centralized and Distributed. 
2) In Centralized source control, a connection to the central server is required for most of the common operations. 
3) Git is a distributed source control system in which most operations are local and do not require a central server.
4) Default Github account is a free account which can have unlimited public repositories.
5) For private repositories, you need to have a paid Github account. Payment increases with no. of private repositories.

-------

Why to prefer command-line over Graphical clients for Git?

1) Best way to learn Git
2) Git was originally designed as a command-line tool. Graphical clients came later.
3) New features are introduced for command-line before they are integrated with the graphical client.
4) Lot of online help is available for command-line tools.
5) Command-line has more power! Most of the graphical clients support only core features. However, command-line supports raw powerful features of Git.
6) Command-line commands are consistent for Windows (Git bash) and Mac/Linux (Terminal/iTerm2).

-------

Why Git is so popular?

1) Even though Git is a distributed/decentralized source control system, it don't have to be distributed.
2) Due to it's distributed nature, git can scale massively.
3) Free and Open source. Lot of active community.
4) Most operations in Git can be performed locally. Only few operations require network connection. 
5) Git is very fast due to local operations.
6) Git is most popular DVCS/VCS (Distributed Version Control System/Version Control System).
7) Git can be easily integrated with other development tools like text editors, bug tracking tools and CI/CD tools like Jenkins.

-------

Key Concepts in Git

1) Repository contains files, history and config managed by Git.
2) Four stages of Git (3 Local and 1 Remote).
3) 3 Local stages -- Working directory, Staging/pre-commit area and Post-commit (Local Repository/History).
4) 1 Remote - Remote Repository 
5) Hidden .git folder in working directory is nothing but a Local Repository.
6) Staging area is also called as Git index, where files are queued up before they are actually committed.

-------

Set initial Git configuration (name and email)
git config --global user.name "Shirish Phatangare (OSV)"
git config --global user.email "shirish.phatangare.osv@fedex.com"

List Git configuration
git config --global --list

.gitconfig file in user's home directory has all the global settings defined above. 
name and email are associated with every commit in commit history.

-------

Clone the repository 
git clone <Repo-URL>

-------

Get the status of your local repository (Basic Git workflow)
git status

1) Default branch for a cloned repo is master (unless different branch specified with git clone <Repo-URL> -b <Branch>)
2) Default reference to remote repo is origin
3) Reference and branch is shown as origin/master in command output. 
4) git status command will compare and show differences between Working directory, Staging area, Local Repo and Remote Repo.
5) When there is nothing to be committed in the working dir, working directory is shown as clean. 
6) Git sees every file in your working copy as one of three:
	a) tracked - a file which has been previously staged or committed.
	b) untracked - a file which has not been staged or committed.
	c) ignored - a file which Git has been explicitly told to ignore.

List all tracked files
git ls-files	

To discard changes in working directory
git restore <file>  
or
git checkout -- <file>

checkout operation takes files from local repo and puts them in a working directory.
checkout can be done for a file, branch or even for a commit.

To add changes from working dir to staging area
git add <file>

To add all changes to staging area
git add . - stages all changes
or
git add -A - stages all changes
git add -u  --> stages modifications and deletions, without new files. (Updates all tracked files) 

To restore staged file back to working dir
git restore --staged <file>
or
git reset HEAD <file>
or
git rm --cached <file>

To restore everything staged
git restore --staged .


Takes the staged snapshot and commits it 
git commit -m 'Initial commit'
git commit <File-Name> -m 'making a change in a branch'

We can combine add and commit as (Express commit)
git commit -am 'Initial commit'

To amend commit message of previous commit
git commit --amend

To pull all the changes from remote  
git pull <Reference> <Branch-Name>
git pull origin master
or just git pull with default reference and branch

Send your committed changes to remote repository. This command specifies that you are pushing to the target branch on origin (the remote server).
git push <Reference> <Branch-Name>
git push origin master
or just git push with default reference and branch

Tip - ALWAYS pull changes before you push anything to remote repo

-------

Text Editor Integration with Git

vi editor is the default editor for Git, which can be changed to other convenient editors.  
Git default editor will be used by commands like - git commit

Windows - Configure Notepad++ with Git

1) Add path of Notepad++ executable in environment variables, so that it can be executed from the git-bash command-line.
2) Create bash alias for Notepad++, so that we can shorten Notepad++ to npp and execute it from the command-line.
3) Create .bashrc file in users home directory with below command.
	alias npp='notepad++.exe -multiInst -nosession'

Tip - Since this is bash, we are creating a .bashrc file. On Mac Terminal, we may need to create .zshrc file which gets executed every time a new terminal window opens.

4) Configure npp as default editor for Git
	git config --global core.editor 'notepad++.exe -multiInst -nosession'


Mac - Configure TextMate2 with Git

1) Install TextMate2 on Mac
2) TextMate --> Preferences --> Terminal --> Install Shell support
3) Edit ./bash_profile file to add below
	export EDITOR="/usr/local/bin/mate -w"
4) With above configuration, we can use Textmate as an editor from Mac Terminal
5) Configure TextMate 2 as a default editor for Git 
	git config --global core.editor 'mate -w'

-------

Basic Git commands

A) Starting a Project

1) Starting with a Fresh Project (git init) - No source yet

Shirish@LAPTOP-7B3OO6RC MINGW64 /C/git-repos
git init Azure_Projects
Initialized empty Git repository in C:/git-repos/Azure_Projects/.git/

2) Adding git to an existing project locally (git init)

Let us say we have an exisitng project web_Project with source code. 

Shirish@LAPTOP-7B3OO6RC MINGW64 /C/git-repos/web_Project
$ git init
Initialized empty Git repository in C:/git-repos/web_Project/.git/

Presence of .git folder in project directory indicates that this project is managed by Git.

3) Joining an existing project on GitHub (fork and clone)

Fork - Making a copy of an upstream repo into your personal account.
Clone - Cloning an exisiting project from remote repo to local repo.


----

Below commands will rename/delete/move files and also stage them

Rename a file 
git mv <OLD-NAME> <NEW-NAME>

Delete a tracked file
git rm <FILE-NAME>

Get help
git <command> -h  (Summary Help)
git help <command> (Detailed Help)

Display history of commits
git log

Commit-Id is noting but a SHA1 hash. Every commit has a SHA1 hash associated with it.
History with short commit ids
git log --abbrev-commit

History for a specific file
git log -- <file>

One line commit history
git log --oneline

Display commit history details
git log --oneline --graph --decorate --all

Create a git alias 'hist' for long git command
git config --global alias.hist <Original git command without 'git' word>
git hist will execute long git command

---------------------------------------------------------------------------------------------
.gitignore - Ignoring Unwanted Files and Folders
---------------------------------------------------------------------------------------------

Git sees every file in your working copy as one of three:
	a) tracked - a file which has been previously staged or committed.
	b) untracked - a file which has not been staged or committed.
	c) ignored - a file which Git has been explicitly told to ignore.

Ignored files are usually build artifacts and machine generated files that can be derived from your repository source or should otherwise not be committed. Some common examples are:

a) dependency caches, such as the contents of /node_modules or /packages
b) compiled code, such as .o, .pyc, and .class files
c) build output directories, such as /bin, /out, or /target
d) files generated at runtime, such as .log, .lock, or .tmp
e) hidden system files, such as .DS_Store or Thumbs.db
f) personal IDE config files, such as .idea/workspace.xml

1) gitignore - Specifies intentionally untracked files to ignore. There are files you don't want Git to check in to GitHub.
2) In Terminal, navigate to the root of your Git repository. Enter 'touch .gitignore' to create a .gitignore file.
3) .gitignore files contain patterns that are matched against file names in your repository to determine whether or not they should be ignored.
4) You can use # to include comments in your .gitignore file.
5) As soon as we add/modify .gitignore file, untracked files in working dir gets ignored.

----

Some common patterns --

**/logs	--	You can prepend a pattern with a double asterisk to match directories anywhere in the repository.

logs/debug.log
logs/monday/foo.bar
build/logs/debug.log

*.log	--	An asterisk is a wildcard that matches zero or more characters.

debug.log
foo.log
.log
logs/debug.log


.log
!important.log	--	Prepending an exclamation mark to a pattern negates it. If a file matches a pattern, but also matches a negating pattern defined later in the file, it will not be ignored.

debug.log
trace.log
but not
important.log
logs/important.log


/debug.log	--	Prepending a slash matches files only in the repository root.

debug.log
but not
logs/debug.log


logs/debug.log	--	Patterns specifying a file in a particular directory are relative to the repository root. (You can prepend a slash if you like, but it doesn't do anything special.)

logs/debug.log
but not
debug.log
build/logs/debug.log


debug.log	--	By default, patterns match files in any directory

debug.log
logs/debug.log


debug?.log	-- A question mark matches exactly one character.

debug0.log
debugg.log
but not
debug10.log	


debug[a-z].log	--	Ranges can be numeric or alphabetic. Square brackets match a single character form the specified set.

debuga.log
debugb.log
but not
debug1.log
debugab.log


logs	--	If you don't append a slash, the pattern will match both files and the contents of directories with that name. In the example matches on the left, both directories and files named logs are ignored

logs
logs/debug.log
logs/latest/foo.bar
build/logs
build/logs/debug.log


logs/	--	Appending a slash indicates the pattern is a directory. The entire contents of any directory in the repository matching that name – including all of its files and subdirectories – will be ignored

logs/debug.log
logs/latest/foo.bar
build/logs/foo.bar
build/logs/latest/debug.log


logs/**/debug.log	--	A double asterisk matches zero or more directories.

logs/debug.log
logs/monday/debug.log
logs/monday/pm/debug.log

----

Ignoring a previously committed file --

If you want to ignore a file that you've committed in the past, you'll need to delete the file from your repository and then add a .gitignore rule for it. Using the --cached option with git rm means that the file will be deleted from your repository, but will remain in your working directory as an ignored file.

A) To untrack a single file that has already been added/initialized to your repository, i.e., stop tracking the file but not delete it from your system use: 
git rm --cached filename

Example - 

$ echo debug.log >> .gitignore
$ git rm --cached debug.log
rm 'debug.log'
$ git commit -m "Start ignoring debug.log"

You can omit the --cached option if you want to delete the file from both the repository and your local file system.

B) To untrack every file that is now in your .gitignore:

First commit any outstanding code changes, and then, run this command:
git rm -r --cached .

This removes any changed files from the index(staging area), then just run:
git add .

Commit it:
git commit -m ".gitignore is now working"

-----

Committing an ignored file --

It is possible to force an ignored file to be committed to the repository using the -f (or --force) option with git add:

$ cat .gitignore
*.log
$ git add -f debug.log
$ git commit -m "Force adding debug.log"

You might consider doing this if you have a general pattern (like *.log) defined, but you want to commit a specific file. However a better solution is to define an exception to the general rule:

$ echo !debug.log >> .gitignore
$ cat .gitignore
*.log
!debug.log
$ git add debug.log
$ git commit -m "Adding debug.log"

-------

Compare and Merge Tools (perforce.com)

Windows - P4Merge For Windows

1) Search for Helix Visual Merge Tool (P4Merge) on perforce.com
2) Install P4Merge For Windows and set env variable to execute it from the command prompt.
3) Configure Git to set P4Merge as default diff/merge tool.

git config --global diff.tool p4merge
git config --global difftool.p4merge.path "C:\Program Files\Perforce\p4merge.exe"
git config --global difftool.prompt false

git config --global merge.tool p4merge
git config --global mergetool.p4merge.path "C:\Program Files\Perforce\p4merge.exe"
git config --global mergetool.prompt false

Mac - P4Merge For Mac

1) Search for Helix Visual Merge Tool (P4Merge) on perforce.com
2) Install P4Merge For Mac and make sure it can be executed from the command prompt.
3) Configure Git to set P4Merge as default diff/merge tool.

git config --global diff.tool p4merge
git config --global difftool.p4merge.path "C:\Program Files\Perforce\p4merge.exe"
git config --global difftool.prompt false

git config --global merge.tool p4merge
git config --global mergetool.p4merge.path "C:\Program Files\Perforce\p4merge.exe"
git config --global mergetool.prompt false

-------

Git Comparisons

Git uses .md file for documentation like README.md (markDown formatted file).
HEAD points to the recent commit in the current branch of local repo.
FETCH_HEAD points to the recent fetch in the current branch of local repo. Use git merge to sync working dir to FETCH_HEAD.
origin/HEAD points to the recent push in the current remote branch.
difftool commands work with same syntax as diff

A) Comparing Working Directory and the Staging Area
git diff

Compare using default diff tool (P4Merge)
git difftool
LHS (Staging Area) and RHS (Working Directory)

B) Comparing Working Directory and Git Repository (Local Repo/HEAD/Last Commit)
git diff HEAD

Compare using default diff tool (P4Merge)
git difftool HEAD
LHS (Local Repo/HEAD/Last Commit) and RHS (Working Directory)

C) Comparing between the Staging Area and the Git Repository (Local Repo/HEAD/Last Commit)
git diff --staged HEAD

Compare using default diff tool (P4Merge)
git difftool --staged HEAD
LHS (Local Repo/HEAD/Last Commit) and RHS (Staging Area)

For file specific comparisons for all above commands use <file> parameter as below
git diff <file>

D) Comparing Between Commits
git log --oneline --> Will display commit history in one line.

git diff <commit1> <commit2> --> Compare commit1 with commit2
git diff <commit1> HEAD --> Compare commit1 with HEAD
git diff HEAD HEAD^ --> Compare HEAD with previous (HEAD - 1)
LHS (HEAD) and RHS (HEAD^)

If there are multiple files to compare, we need to quit difftool to move comparison to next file.

E) Comparing Between Local and Remote Master Branches

Below command compares master branch @HEAD (Last commit Local Repo) to origin/master branch (Remote Repo)
git diff master origin/master

Compare using default diff tool (P4Merge)
git difftool master origin/master
LHS (master) and RHS (origin/master)

We can also compare 2 local branches
git diff master new-local-branch

-------

Branching and Merging

1) Directly working on a master branch is not a good practice. Always create feature braches and merge them back to master once features are stabilised.


List all Local branches
git branch

List all Local and Remote branches
git branch -a

Creates a branch but does not switch you to that branch
git branch <Branch-Name>

Checkout the new branch you just created to start using it.
git checkout <Branch-Name>

Create and Checkout the branch (Express Checkout)
git checkout -b <Branch-Name>

Rename a branch locally
git branch -m <OLD-NAME> <NEW-NAME>

Delete a branch locally
git branch -d <BRANCH-NAME>

Tip - You can not delete a current branch, Switch branch and then delete

----

A) Happy Path / Fast Forward Merges (No Changes in Master before we merge back)

In Fast Forward merge, we do not preserve the fact that we branched off from master and merged back.

We should not commit anything to master branch, when we are committing to new branches created from master branch and merging them back to master (Fast-forward Merge).

a) Create a new local branch from master and commit to it
b) Switch to master
c) use below command to merge from src to master
git merge <Source_Branch>

Display commit history details
git log --oneline --graph --decorate --all

B) Happy Path / Disable Fast Forward Merges (No Changes in Master before we merge back)

We preserve the fact that we branched off from master and merged back.

a) Create a new local branch from master and commit to it
b) Switch to master
c) use below command to merge from src to master without Fast Forward
git merge <Source_Branch> --no-ff

C) Automatic Merges (Commit Changes to Master before we merge back)

a) Create a new local branch from master and commit to it
b) Switch to master and commit to master
c) use below command to merge from src to master with automatic merge
git merge <Source_Branch> 

---

Resolving Merge Conflicts

a) Create a new local branch from master and commit to it (file sample.html)
b) Switch to master and commit to same file sample.html, so that there are conflicts.
c) Now there are merge conflicts and we need to resolve them before merging.
d) use below command to merge from src to master with automatic merge.  Automatic merge fails here!
git merge <Source_Branch> 

e) Use P4Merge as a merge tool to resolve conflicts.
git mergetool 

Above command will automatically open conflicting files in P4Merge tool.
f) Fix conflicts in all confilcting files in P4Merge tool and commit changes.
git commit -m "Resolved all merge conflicts".
g) Add *.orig files in .gitignore and commit it.
h) *.orig files are temporary merge backup files which are created to save original conflicted state so that we can revisit if required.

----

Rebasing

Rebasing is a concept where we create feature branch from the master branch, commit to both feature and master branches and then at certain point in time rebase from master to feature branch.

A) Simple Rebase

a) Create a new local branch from master and commit to it (file sample1.html)
b) Switch to master and commit to different file sample2.html.
c) Switch back to the feature branch (<Dest_Branch>)
d) Use below command to rebase from master to the feature branch.
git rebase <Src_Branch> (master is src) 

Rewind changes happened on feature branch to state when feature branch was created.
Then apply all the commits on master branch
Then apply all the commits on feature branch
Now we are in rebased state (graph is flattened) where we can fast-forward merge from feature to master. (Since there are no new commits on master)

Display commit history details
git log --oneline --graph --decorate --all

B) Rebasing conflict scenario

a) Create a new local branch from master and commit to it (file sample.html)
b) Switch to master and commit to same file sample.html so that there are conflicts to resolve.
c) Switch back to the feature branch (<Dest_Branch>)
d) Use below command to rebase from master to the feature branch.
git rebase <Src_Branch> (master is src) 

e) At this stage, we are in a conflicting state. Use merge tool to resolve conflicts.
git margetool

f) Once all conflicts are fixed using mergetool P4Merge and we are already in Rebase state, simply run git rebase --continue
g) Now we are in rebased state (graph is flattened) where we can fast-forward merge from feature to master. (Since there are no new commits on master)

To abort rebase use
git rebase --abort

C) Pull with Rebase (GitHub)

Fetch changes from the remote (origin/master)
git fetch origin master

git fetch is a non-distructive command which just updates the references between remote repo and local repo.
git pull = git fetch + git merge

If there are some changes done in the remote repo (origin/master), git status command will not show those changes.
If we need to see those changes in git status command, we need to first fetch changes from remote to local. 

Traditional merge with git pull or git merge will simply merge changes from remote to local as they happened (no changes in timeline). However,
git pull origin master 

git pull with rebase will put changes in origin/master (remote) before local commits.
git pull --rebase origin master 

----

Stashing

A) Simple Stash

Stashed files are files which are work-in-progress files which are not yet ready for staging or commiting.
We stash such temporary files to save our progress and move on to other files.

1) Change a file sample.html in the working directory.
2) sample.html is work-in-progress file which is not yet ready for commit. However, I need to move to other higher priority tasks.
3) In order to stash current state of working directory and staging area (index) give below command
git stash
4) Now if we check status using 'git status' command, we can see that we have a clean working directory (tree).
5) Notice that now we do not see changes made in the stashed files. 
6) Start working on other high priority tasks and commit related files. Now we have clean working dir/tree again.
7) Now we can start working on stashed file where we left them.
git stash apply
8) We are back to work in progress status and can continue working on sample.html file.

To list all the stashes 
git stash list

To drop the last stash
git stash drop

----

B) Stashing Untracked Files and Using Pop

By default, git will stash only tracked files.
Remember we can list all the tracked files using - git ls-files

1) Change a tracked file sample.html in the working directory.
2) Add a new file newFile.html (untracked file) in the working directory
3) git status will show sample.html as modified and newFile.html as untracked.
4) If we issue git stash command, it will only stash tracked file (sample.html).
5) One way to solve this is to add newFile.html to the staging area (git add). Now, this way newFile.html will be a tracked file which can be stashed.
6) However, we can do it without adding it to the staging area as below
git stash -u
-u flag will stash untracked files(not excluded by .gitignore) along with tracked files.

Express git stash apply and git stash drop (works like stash stack)
git stash pop

---

C) Managing Multiple Stashes

If we use just 'git stash' command, we are dealing with only one stash. However, to deal with multiple stashes we need to give stash message for each stash.  
That way we can keep track of multiple stashes.

1) Update 3 tracked files sample1.html, sample2.html and sample3.html and create 3 stashes (one for each file).

git stash save "sample1.html - Stash 1"
git stash save "sample2.html - Stash 2"
git stash save "sample3.html - Stash 3"

2) List all 3 stashes
git stash list 

3) Get the details of a particular stash
git stash show <STASH-Reference>
git stash show stash@{1}

4) Retrieve/apply a particular stash
git stash apply <STASH-Reference>
git stash apply stash@{1}

5) Drop a particular stash
git stash drop <STASH-Reference>
git stash drop stash@{1}

6) Drop all the stashes
git stash clear

---

D) Stashing into a Branch

When working on one branch (say master), we can stash our changes to another branch (say feature).

1) Update and add few files on master branch and stash them
git stash -u 

2) Retrieve stash into another branch 'newfeature'
git stash branch <BRANCH_NAME>
git stash branch newfeature

Below things happen when above command is executed
	a) A new branch 'newfeature' is created
	b) Branch is switched to new branch 'newfeature'
    c) Stash is applied to new branch 'newfeature'
	d) Stash is dropped. Stash is not branch-specific. When it is dropped, it is dropped for all the branches.

-------

Git Tagging

A) Simple tagging (Lightweight Tags)

We can mark significant events or milestones for commits in Git repo using git tagging.
Tag is nothing but a label that we can apply to any commit in history.

Create a Lightweight Tag. This tag is applied to the last commit (HEAD) by default since no specific commit is mentioned in command.
git tag <TAG-NAME>

List all the tags
git tag --list

We can use name of tag in other commands as a reference.
Display details of commit associated with a tag.
git show <TAG-NAME>

Delete a tag
git tag --delete <TAG-NAME>

---

B) Annotated Tags (Tags with information)

Below command will open a default editor to annotate tag with more information
git tag -a <TAG-NAME>

Alternatively, we can also use below 
git tag <TAG-NAME> -m "Creating Tag 1.0"

---

C) Comparing Tags

Compare commits associated with two tags
git diff <TAG-NAME1> <TAG-NAME2>
git difftool <TAG-NAME1> <TAG-NAME2>

---

D) Tagging a previous commit (sometimes you forget to tag)

Apply an annotated tag to previous commit. This will open an editor to annotate tag.
git tag -a <TAG-NAME> <COMMIT-ID>

---

E) Updating an existing commit (Sometimes you tag the wrong commit)

Force tag to correct commit id. This command will move tag <TAG-NAME> from wrong <COMMIT-ID> to correct <COMMIT-ID>.
git tag -a <TAG-NAME> -f <COMMIT-ID>

---

F) Remote Tagging (Working with tags on GitHub)

All above commands add tags to local commits only (Local Repo). We have to push these tags to remote repo to sync tags on both local and remote repos.

Push single tag to remote (commit associated with tag is also pushed to gitHub)
git push origin <TAG-NAME>

To push all local tags to remote at once
git push origin <BRANCH-NAME> --tags

GitHub creates src folders in zip and tar.gz formats for each tag on remore repo.

Delete a Tag on GitHub (Delete accidently pushed Tag). It will still be there on local but not on remote.
git push origin :<TAG-NAME>

--------------------------------






















































     	














































